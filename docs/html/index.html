<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nivel de Superficies Digital: Nivel de Superficies Digital</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nivel de Superficies Digital
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Nivel de Superficies Digital </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_jez_Documents_U_CESE_CESE_PdM_README"></a> Este proyecto fue creado con el objetivo de funcionar como TP final para las materias "Protocolos de Comunicación en Sistemas Embebidos" y "Programación de Microcontroladores" de la <b>Carrera de Especialización en Sistemas Embebidos</b> de la UBA.</p>
<p>El proyecto consiste en un <b>Nivel de Superficies Digital</b> que simula el funcionamiento del clásico <em>nivel de burbuja</em> utilizado en carpintería, pero implementado digitalmente. Utiliza un acelerómetro MPU-6500 para medir la inclinación de una superficie en los ejes X e Y, representando el desplazamiento de la burbuja en una matriz de LEDs 8x8. Se modeló la aplicación como una máquina de estado finito cuyos estados se corresponden a los modos de funcionamiento: <em>medición simple del nivel de una superficie</em> o <em>comparador de superficies</em>. Este segundo modo permite almacenar una medición y compararla con otra en simultáneo.</p>
<p>El sistema está basado en una placa STM32 NUCLEO-F446RE, y emplea los siguientes protocolos de comunicación para comunicarse con los módulos de entradas y salidas: I²C para el acelerómetro, SPI para la matriz de LEDs y UART para mostrar los valores de entrada y salida por el monitor serial.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Estructura del Proyecto</h1>
<p>La aplicación del nivel de superficies se encuentra desarrollada en el archivo <code><a class="el" href="main_8c.html" title="Nivel de Superficies Digital.">main.c</a></code>. La documentación del proyecto fue generada con <em>Doxygen</em>, el archivo <code>Doxyfile</code> y la documentación generada en <code>html</code> se encuentran en la carpeta <code>docs/</code> ubicada a nivel de proyecto.</p>
<p>Esta aplicación utiliza varios drivers específicos desarrollados para facilitar el uso de retardos no bloqueantes, el debounce del botón utilizado para cambiar de modo y el envío de datos mediante la UART. Estos drivers específicos fueron desarrollados como parte de las prácticas de la materia <em>Programación de Microcontroladores</em> y mejorados o adaptados para este proyecto, se encuentran ubicados en la carpeta <a class="el" href="md__home_jez_Documents_U_CESE_CESE_PdM_Drivers_API_README.html">API/</a>.</p>
<p>Para la configuración y comunicación con los módulos externos seleccionados para el proyecto (el acelerómetro y el display de LEDs) se desarrollaron los <em>Device Drivers</em> correspondientes que se encuentran ubicados respectivamente en las carpetas <code>ledMatrix_MAX7219/</code> y <code>GY521_MPU6500/</code>, acompañados de su respectiva documentación.</p>
<div class="fragment"><div class="line">TP_nivel_burbuja/                                                </div>
<div class="line">├── README.md                          # README del proyecto (a nivel aplicación) </div>
<div class="line">├── docs/                              </div>
<div class="line">|    ├── Doxyfile                      # Doxyfile del proyecto</div>
<div class="line">|    └── html/                         # Documentación del proyecto (en HTML) generada con Doxygen</div>
<div class="line">├── Core/                              </div>
<div class="line">|    ├── Inc/                            </div>
<div class="line">|    |    ├── main.h                             </div>
<div class="line">|    |    └── …                          </div>
<div class="line">|    ├── Src/                            </div>
<div class="line">|    |    ├── main.c                   # Archivo principal de la aplicación         </div>
<div class="line">|    |    └── …                        </div>
<div class="line">└── Drivers/                            </div>
<div class="line">     ├── API/                          # Drivers Específicos</div>
<div class="line">     |    ├── README.md                # README de los drivers específicos         </div>
<div class="line">     |    ├── Inc/                     </div>
<div class="line">     |    |    ├── API_delay.h         # Proporciona funciones para retardos no bloqueantes                 </div>
<div class="line">     |    |    ├── API_debounce.h      # Implementa una máquina de estados para el debounce de botón                   </div>
<div class="line">     |    |    └── API_uart.h          # Interfaz para la configuración y uso de UART2               </div>
<div class="line">     |    └── Src/                        </div>
<div class="line">     |         ├── API_delay.c         # Implementación de las funciones de retardo no bloqueante                 </div>
<div class="line">     |         ├── API_debounce.c      # Implementación de la máquina de estados de debounce                   </div>
<div class="line">     |         └── API_uart.c          # Implementación de las funciones de UART2    </div>
<div class="line">     |                  </div>
<div class="line">     ├── ledMatrix_MAX7219/            # Device Driver para Matrix de LEDs de 8x8 con controlador MAX7219           </div>
<div class="line">     |    ├── README.md                # README del driver       </div>
<div class="line">     |    ├── docs/                    # Documentación sobre el driver</div>
<div class="line">     |    ├── Inc/                       </div>
<div class="line">     |    |    ├── ledMatrix.h         # Interfaz de alto nivel del driver                           </div>
<div class="line">     |    |    └── ledMatrix_port.h    # Interfaz de bajo nivel (acceso al hardware)                     </div>
<div class="line">     |    └── Src/                          </div>
<div class="line">     |         ├── ledMatrix.c         # Implementación de funciones de alto nivel                </div>
<div class="line">     |         └── ledMatrix_port.c    # Implementación de funciones específicas del hardware y comunicación por SPI   </div>
<div class="line">     |                 </div>
<div class="line">     └── GY521_MPU6500/                # Device Driver para el acelerómetro del GY-521 con controlador MPU-6500         </div>
<div class="line">          ├── README.md                # README del driver       </div>
<div class="line">          ├── docs/                    # Documentación sobre el driver     </div>
<div class="line">          ├── Inc/                       </div>
<div class="line">          |    ├── GY521.h             # Interfaz de alto nivel del driver                       </div>
<div class="line">          |    └── GY521_port.h        # Interfaz de bajo nivel (acceso al hardware)                 </div>
<div class="line">          └── Src/                          </div>
<div class="line">               ├── GY521.c             # Implementación de funciones de alto nivel               </div>
<div class="line">               └── GY521_port.c        # Implementación de funciones específicas del hardware y comunicación por I²C                 </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25"></a>
Máquina de Estados Finitos en la aplicación</h1>
<p>El comportamiento de la aplicación es el siguiente:</p><ul>
<li>el modo normal de funcionamiento del dispositivo es una medición simple del nivel de la superficie, mediante el cual se detecta la inclinación del módulo mediante las lecturas del acelerómetro y se grafica una "burbuja" en el display de LEDs que representa dicha inclinación</li>
<li>al presionar un botón, el nivel actual es "fijado" en la pantalla (el led se fija en la posición actual) y una segunda "burbuja" acompaña el movimiento</li>
<li>cuando ambos niveles se encuentran alineados se veran ambas "burbujas" en la misma posición (un solo led encendido)</li>
<li>para salir del modo de comparación se presiona nuevamente el botón y se retorna al modo normal de medición simple.</li>
</ul>
<p>Para modelar este comportamiento se utilizó el modelo de <b>MEF de Mealy</b>, en el que las salidas dependen del <em>estado actual</em> y de <em>las entradas</em>. Para ello se definen los estados de la siguiente forma:</p>
<ul>
<li>MEDICIÓN_SIMPLE: En este estado, la aplicación funciona como medidor del nivel de la superficie actual.</li>
<li>COMPARACIÓN_DE_NIVELES: En este estado la aplicación permite comparar el nivel de la superficie actual contra un nivel previo fijado.</li>
</ul>
<p>Las entradas son las siguientes:</p>
<ul>
<li>Lecturas de acelerómetro: Las lecturas obtenidas de los ejes X e Y del acelerómetro.</li>
<li>Pulsación del botón: Cada pulsación del botón será una entrada para la aplicación.</li>
</ul>
<p>Las salidas son las siguientes:</p>
<ul>
<li>Posición de la burbuja móvil en la pantalla de LEDs.</li>
<li>Prescencia y posición de la burbuja fija en la pantalla de LEDs.</li>
</ul>
<p><img src="./docs/html/docs/MEF_nivel_burbuja.jpg" alt="" class="inline"/> <img src="./docs/MEF_nivel_burbuja.jpg" alt="" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md26"></a>
Funciones Principales</h1>
<ul>
<li><a class="el" href="main_8c.html#ab770accc0a3c32281d41a7d3951103f6" title="Inicializa la FSM del nivel de burbuja.">bubbleInit()</a>: Inicializa la MEF y los periféricos.</li>
<li><a class="el" href="main_8c.html#a1c6e3311d3a8710ce72a2d7eaa9ee743" title="Actualiza la FSM del nivel de burbuja.">bubbleUpdate()</a>: Actualiza el estado de la burbuja, incluyendo la lectura del acelerómetro y el procesamiento del botón.</li>
<li><a class="el" href="main_8c.html#a88fa672843b988a199b78049c65d2e3e" title="Genera el buffer de pantalla a partir de la posición (o posiciones) especificada.">drawMatrix()</a>: Genera el buffer de pantalla para renderizar en la matriz de LEDs.</li>
<li><a class="el" href="main_8c.html#ae2d33623859408b0923249f4a261caf0" title="Realiza el mapping entre los valores obtenidos del acelerómetro y la posición de la burbuja.">mapAccelToPosition()</a>: Mapea los valores del acelerómetro a las coordenadas de la matriz.</li>
<li><a class="el" href="main_8c.html#aeb2f5c0dd95e9909dd6942d7fc22f14e" title="Envía los valores de entrada y salida por la UART.">sendOutputsByUart()</a>: Envía los valores de entrada y salida por la UART.</li>
<li><a class="el" href="main_8c.html#a334a5aad6b1689ef45ac4b93cf4f6884" title="Guarda la posición actual de la burbuja para utilizarla para el modo de Comparación de Niveles.">saveCurrentLevel()</a>: Guarda la posición actual de la burbuja para utilizarla para la comparación.</li>
<li><a class="el" href="main_8c.html#a199edc37e5eb3bb6578fb19093cec6da" title="Descarta la posición guardada de la burbuja para el modo de Comparación de Niveles.">deleteSavedLevel()</a>: Borra la posición guardada de la burbuja fija.</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Perfiféricos utilizados</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Módulo I²C:</h2>
<p>Utilizado para la comunicación con el GY-521 (MPU-6500). Se configuró de la siguiente manera:</p><ul>
<li>Velocidad del reloj: 100KHz</li>
<li>Largo de direcciones: 7 bits</li>
<li>Pin SCL: Puerto B pin 8</li>
<li>Pin SDA: Puerto B pin 9</li>
<li>Interrupciones: deshabilitadas.</li>
<li>DMA: deshabilitado.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
Módulo SPI:</h2>
<p>Utilizado para la comunicación con la matriz de LEDs 8x8 (MAX7219). Se configuró de la siguiente manera:</p><ul>
<li>Modo: simplex, sólo MOSI.</li>
<li>Tamaño de transmisión: 8 bits</li>
<li>Endianness: MSB first</li>
<li>Polaridad del Reloj (CPOL): 1 (HIGH)</li>
<li>Fase del reloj (CPHA): 0 (leading edge)</li>
<li>Baud Rate: 1.3125 Mbits/s</li>
<li>Pin SCK: Puerto A pn 5</li>
<li>Pin MOSI: Puerto A pin 7</li>
<li>Pin CS: Puerto B pin 6</li>
<li>Interrupciones: deshabilitadas.</li>
<li>DMA: deshabilitado.</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
Módulo UART:</h2>
<p>Para mostrar los valores del acelerómetro y la posición de la burbuja en la matriz por el monitor serial. Se configuró de la siguiente manera:</p><ul>
<li>Interfaz: UART2</li>
<li>Baud Rate: 115200 bps</li>
<li>Tamaño del frame: 8 bits</li>
<li>Paridad: No</li>
<li>Bits de stop: 1</li>
<li>Control de flujo por hardware: deshabilitado.</li>
<li>Interrupciones: deshabilitadas.</li>
<li>DMA: deshabilitado.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
Timers:</h2>
<p>Para gestionar el tiempo entre lecturas del acelerómetro y actualizar la matriz. Se utilizó el <em>SysTick</em>.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
GPIO:</h2>
<p>Para cambiar de modo de trabajo en la aplicación se utilizó el botón 1. Este botón se encuentra incorporado en la placa NUCLEO y se encuentra conectado al <em>puerto C pin 13</em>.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Drivers implementados</h1>
<h2><a class="anchor" id="autotoc_md34"></a>
GY521_MPU6500 (I2C)</h2>
<p><a class="el" href="md__home_jez_Documents_U_CESE_CESE_PdM_Drivers_GY521_MPU6500_README.html">Link a la documentación del driver</a></p>
<p>Este Device Driver es un Polled Driver que permite configurar y controlar el acelerómetro del módulo comercial GY-521 que utiliza el controlador MPU-6500.</p>
<p>El propósito de este driver es facilitar la lectura valores del acelerómetro a través de la interfaz I²C y operar con el acelerómetro en diferentes modos de alimentación.</p>
<p>El diseño del driver sigue una arquitectura modular por capas, donde la capa superior o de alto nivel funciona como abstracción del hardware, presentando una interfaz más amigable hacia el usuario. Entre las funcionalidades presentadas mediante la interfaz al usuario se encuentran:</p><ul>
<li>Inicializar el sensor en modos de bajo consumo o bajo ruido.</li>
<li>Leer las mediciones del acelerómetro en los tres ejes (X, Y, Z) mediante una función sencilla.</li>
<li>Calibrar el offset en cada eje al inicializar el dispositivo y ajustar las mediciones realizadas con dichos valores.</li>
</ul>
<p>La capa inferior o de bajo nivel de este driver concentra la comunicación con el hardware mediante el protocolo I²C, utilizando las funciones que provee la HAL de STM32. Entre las funcionalidades de la capa de bajo nivel se encuentran:</p><ul>
<li>Lectura de 1 hasta 14 registros contiguos del controlador MPU-6500.</li>
<li>Escritura de un registro específico del controlador MPU-6500.</li>
<li>Posibilidad de saber si las operaciones se realizaron exitosamente o con errores, mediante los valores de retorno de las funciones.</li>
</ul>
<p>Este driver tiene el siguiente alcance y limitaciones:</p><ul>
<li>Se encuentra diseñado específicamente para el acelerómetro del modelo de controlador MPU-6500. Otros sensores pueden requerir configuraciones distintas y no se recomienda el uso de este driver.</li>
<li>No se implementa el uso del giroscopio ni del sensor de temperatura presentes en el controlador MPU-6500.</li>
<li>Se encuentran implementados dos modos de operación: Low-Power Accelerator Mode y Low-Noise Accelerator Mode tal como se describen en el datasheet del MPU-6500, sin uso del sensor de temperatura. No se encuentran implementados los modos descritos como Sleep Mode, Standby Mode, Gyroscope Mode o 6-Axis Mode, dejándose para una posible implementación posterior.</li>
</ul>
<h2><a class="anchor" id="autotoc_md35"></a>
ledMatrix_MAX7219 (SPI)</h2>
<p><a class="el" href="md__home_jez_Documents_U_CESE_CESE_PdM_Drivers_ledMatrix_MAX7219_README.html">Link a la documentación del driver</a></p>
<p>Este Device Driver es un Polled Driver que permite configurar y controlar una matriz de LEDs de 8x8 que utiliza el controlador MAX7219.</p>
<p>El propósito de este driver es facilitar el renderizado de un buffer de pantalla previamente generado, en la matriz de LEDs a través de la interfaz SPI, de forma similar a como se trabajaría cualquier otro display gráfico de mayor complejidad.</p>
<p>El diseño del driver sigue una arquitectura modular por capas, donde la capa superior o de alto nivel funciona como abstracción del hardware, presentando una interfaz más amigable hacia el usuario. Entre las funcionalidades presentadas mediante la interfaz al usuario se encuentran:</p><ul>
<li>Inicializar el controlador MAX7219 para trabajar con la matriz de LEDs.</li>
<li>Setear la intensidad de los LEDs de forma simple con 3 niveles predefinidos.</li>
<li>Activar y desactivar el modo SHUTDOWN de la matriz.</li>
<li>Limpiar el display (apagar todos los LEDs).</li>
<li>Renderizar un buffer de pantalla en el display de LEDs.</li>
</ul>
<p>La capa inferior o de bajo nivel de este driver concentra la comunicación con el hardware mediante el protocolo SPI, utilizando las funciones que provee la HAL de STM32. Entre las funcionalidades de la capa de bajo nivel se encuentran:</p><ul>
<li>Setear un pin determinado en HIGH o LOW (utilizado para activar la comunicación mediante el pin designado como Chip Select.</li>
<li>Enviar un comando o instrucción y su correspondiente valor por SPI.</li>
<li>Posibilidad de saber si el envío de la instrucción se realizó exitosamente o con errores, mediante el valor de retorno de la función.</li>
</ul>
<p>Este driver tiene el siguiente alcance y limitaciones:</p><ul>
<li>Está diseñado para manejar una sola matriz y no puede manejar múltiples matrices en cascada sin antes extender la lógica de transmisión SPI.</li>
<li>No admite operaciones de lectura, por lo que se compone únicamente de operaciones de escritura o comandos enviados a la matriz de LEDs para su control.</li>
<li>No permite renderización parcial del display. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
